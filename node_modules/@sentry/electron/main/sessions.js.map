{"version":3,"file":"sessions.js","sources":["../src/src/main/sessions.ts"],"sourcesContent":["import {\n  captureSession,\n  endSession as endSessionCore,\n  getClient,\n  getCurrentScope,\n  makeSession,\n  startSession as startSessionCore,\n  updateSession,\n} from '@sentry/core';\nimport { flush, NodeClient } from '@sentry/node';\nimport { SerializedSession, Session, SessionContext, SessionStatus } from '@sentry/types';\nimport { logger } from '@sentry/utils';\nimport { app } from 'electron';\n\nimport { getSentryCachePath } from './fs';\nimport { Store } from './store';\n\nconst PERSIST_INTERVAL_MS = 60_000;\n\n/** Stores the app session in case of termination due to main process crash or app killed */\nlet sessionStore: Store<SessionContext | undefined> | undefined;\n/** Previous session if it did not exit cleanly */\nlet previousSession: Promise<Partial<Session> | undefined> | undefined;\n\nfunction getSessionStore(): Store<SessionContext | undefined> {\n  if (!sessionStore) {\n    sessionStore = new Store<SessionContext | undefined>(getSentryCachePath(), 'session', undefined);\n    previousSession = sessionStore.get();\n  }\n\n  return sessionStore;\n}\n\nlet persistTimer: NodeJS.Timer | undefined;\n\n/** Starts a session */\nexport function startSession(sendOnCreate: boolean): void {\n  const session = startSessionCore();\n\n  if (sendOnCreate) {\n    captureSession();\n  }\n\n  getSessionStore()\n    .set(session)\n    .catch(() => {\n      // Does not throw\n    });\n\n  // Every PERSIST_INTERVAL, write the session to disk\n  persistTimer = setInterval(async () => {\n    const currentSession = getCurrentScope().getSession();\n    // Only bother saving if it hasn't already ended\n    if (currentSession && currentSession.status === 'ok') {\n      await getSessionStore().set(currentSession);\n    }\n  }, PERSIST_INTERVAL_MS);\n}\n\n/** Cleanly ends a session */\nexport async function endSession(): Promise<void> {\n  // Once the session had ended there is no point persisting it\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  const session = getCurrentScope().getSession();\n\n  if (session) {\n    if (session.status === 'ok') {\n      logger.log('Ending session');\n      endSessionCore();\n    } else {\n      logger.log('Session was already ended');\n    }\n  } else {\n    logger.log('No session');\n  }\n\n  await getSessionStore().clear();\n\n  await flush(2_000);\n}\n\n/** Determines if a Date is likely to have occurred in the previous uncompleted session */\nexport async function unreportedDuringLastSession(crashDate: Date | undefined): Promise<boolean> {\n  if (!crashDate) {\n    return false;\n  }\n\n  const previousSessionModified = await getSessionStore().getModifiedDate();\n  // There is no previous session\n  if (previousSessionModified === undefined) {\n    return false;\n  }\n\n  const previousSessionModifiedTime = previousSessionModified.getTime();\n  const crashTime = crashDate.getTime();\n\n  // Session could have run until modified time + persist interval\n  const prevSessionEnd = previousSessionModifiedTime + PERSIST_INTERVAL_MS;\n\n  // Event cannot have occurred before last persist time, We add a 2 second overlap to be sure\n  const lastPersist = previousSessionModifiedTime - 2_000;\n\n  // If the crash occurred between the last persist and estimated end of session\n  return crashTime > lastPersist && crashTime < prevSessionEnd;\n}\n\n/** Checks if the previous session needs sending as crashed or abnormal  */\nexport async function checkPreviousSession(crashed: boolean): Promise<void> {\n  const client = getClient<NodeClient>();\n\n  const previous = await previousSession;\n\n  if (previous && client) {\n    // Ignore if the previous session is already ended\n    if (previous.status !== 'ok') {\n      previousSession = undefined;\n      return;\n    }\n\n    const status: SessionStatus = crashed ? 'crashed' : 'abnormal';\n\n    logger.log(`Found previous ${status} session`);\n\n    const sesh = makeSession(previous);\n\n    updateSession(sesh, {\n      status,\n      errors: (sesh.errors || 0) + 1,\n      release: (previous as unknown as SerializedSession).attrs?.release,\n      environment: (previous as unknown as SerializedSession).attrs?.environment,\n    });\n\n    await client.sendSession(sesh);\n\n    previousSession = undefined;\n  }\n}\n\n/** Sets the current session as crashed */\nexport function sessionCrashed(): void {\n  // stop persisting session\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  logger.log('Session Crashed');\n  const session = getCurrentScope().getSession();\n\n  if (!session) {\n    logger.log('No session to update');\n    return;\n  }\n\n  if (session.status === 'ok') {\n    logger.log('Setting session as crashed');\n    const errors = session.errors + 1;\n    updateSession(session, { status: 'crashed', errors });\n  } else {\n    logger.log('Session already ended');\n  }\n\n  captureSession();\n}\n\n/** Sets the current session as ANR */\nexport function sessionAnr(): void {\n  // stop persisting session\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  const session = getCurrentScope().getSession();\n\n  if (!session) {\n    return;\n  }\n\n  if (session.status === 'ok') {\n    logger.log('Setting session as abnormal ANR');\n    updateSession(session, { status: 'abnormal', abnormal_mechanism: 'anr_foreground' });\n    captureSession();\n  }\n}\n\n/**\n * End the current session on app exit\n */\nexport function endSessionOnExit(): void {\n  // 'before-quit' is always called before 'will-quit' so we listen there and ensure our 'will-quit' handler is still\n  // the last listener\n  app.on('before-quit', () => {\n    // We track the end of sessions via the 'will-quit' event which is the last event emitted before close.\n    //\n    // We need to be the last 'will-quit' listener so as not to interfere with any user defined listeners which may\n    // call `event.preventDefault()` to abort the exit.\n    app.removeListener('will-quit', exitHandler);\n    app.on('will-quit', exitHandler);\n  });\n}\n\n/** Handles the exit */\nconst exitHandler: (event: Electron.Event) => Promise<void> = async (event: Electron.Event) => {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  logger.log('[Session] Exit Handler');\n\n  // Stop the exit so we have time to send the session\n  event.preventDefault();\n\n  try {\n    // End the session\n    await endSession();\n  } catch (e) {\n    // Ignore and log any errors which would prevent app exit\n    logger.warn('[Session] Error ending session:', e);\n  }\n\n  app.exit();\n};\n"],"names":["Store","getSentryCachePath","startSessionCore","captureSession","__awaiter","getCurrentScope","logger","endSessionCore","flush","getClient","makeSession","updateSession","app"],"mappings":"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"}
{"version":3,"file":"store.js","sources":["../../src/main/store.ts"],"sourcesContent":["import { logger } from '@sentry/utils';\nimport { dirname, join } from 'path';\n\nimport { Mutex } from '../common/mutex';\nimport { mkdirp, readFileAsync, statAsync, unlinkAsync, writeFileAsync } from './fs';\n\nconst dateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.*\\d{0,10}Z$/;\n\n/** JSON revive function to enable de-serialization of Date objects */\nfunction dateReviver(_: string, value: any): any {\n  if (typeof value === 'string' && dateFormat.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n}\n\n/**\n * Stores data serialized to a JSON file.\n */\nexport class Store<T> {\n  /** Current state of the data. */\n  protected _data?: T;\n\n  /** Internal path for JSON file. */\n  private readonly _path: string;\n  /** Value used to initialize data for the first time. */\n  private readonly _initial: T;\n  /** A mutex to ensure that there aren't races while reading and writing files */\n  private readonly _lock: Mutex;\n\n  /**\n   * Creates a new store.\n   *\n   * @param path A unique filename to store this data.\n   * @param id A unique filename to store this data.\n   * @param initial An initial value to initialize data with.\n   */\n  public constructor(path: string, id: string, initial: T) {\n    this._lock = new Mutex();\n    this._path = join(path, `${id}.json`);\n    this._initial = initial;\n  }\n\n  /**\n   * Updates data by replacing it with the given value.\n   * @param data New data to replace the previous one.\n   */\n  public async set(data: T): Promise<void> {\n    await this._lock.runExclusive(async () => {\n      this._data = data;\n\n      try {\n        if (data === undefined) {\n          try {\n            await unlinkAsync(this._path);\n          } catch (_) {\n            //\n          }\n        } else {\n          await mkdirp(dirname(this._path));\n          await writeFileAsync(this._path, JSON.stringify(data));\n        }\n      } catch (e) {\n        logger.warn('Failed to write to store', e);\n        // This usually fails due to anti virus scanners, issues in the file\n        // system, or problems with network drives. We cannot fix or handle this\n        // issue and must resume gracefully. Thus, we have to ignore this error.\n      }\n    });\n  }\n\n  /**\n   * Returns the current data.\n   *\n   * When invoked for the first time, it will try to load previously stored data\n   * from disk. If the file does not exist, the initial value provided to the\n   * constructor is used.\n   */\n  public async get(): Promise<T> {\n    return this._lock.runExclusive(async () => {\n      if (this._data === undefined) {\n        try {\n          this._data = JSON.parse(await readFileAsync(this._path, 'utf8'), dateReviver) as T;\n        } catch (e) {\n          this._data = this._initial;\n        }\n      }\n\n      return this._data;\n    });\n  }\n\n  /**\n   * Updates data by passing it through the given function.\n   * @param fn A function receiving the current data and returning new one.\n   */\n  public async update(fn: (current: T) => T): Promise<void> {\n    await this.set(fn(await this.get()));\n  }\n\n  /** Returns store to its initial state */\n  public async clear(): Promise<void> {\n    await this.set(this._initial);\n  }\n\n  /** Gets the Date that the file was last modified */\n  public async getModifiedDate(): Promise<Date | undefined> {\n    try {\n      return (await statAsync(this._path))?.mtime;\n    } catch (_) {\n      return undefined;\n    }\n  }\n}\n\n/**\n * Extends Store to throttle writes.\n */\nexport class BufferedWriteStore<T> extends Store<T> {\n  /** A write that hasn't been written to disk yet */\n  private _pendingWrite: { data: T; timeout: NodeJS.Timeout } | undefined;\n\n  /**\n   * Creates a new ThrottledStore.\n   *\n   * @param path A unique filename to store this data.\n   * @param id A unique filename to store this data.\n   * @param initial An initial value to initialize data with.\n   * @param throttleTime The minimum time between writes\n   */\n  public constructor(path: string, id: string, initial: T, private readonly _throttleTime: number = 500) {\n    super(path, id, initial);\n  }\n\n  /** @inheritdoc */\n  public override async set(data: T): Promise<void> {\n    this._data = data;\n\n    this._pendingWrite = {\n      // We overwrite the data for the pending write so that the latest data is written in the next flush\n      data,\n      // If there is already a pending timeout, we keep that rather than starting the timeout again\n      timeout: this._pendingWrite?.timeout || setTimeout(() => this._writePending(), this._throttleTime),\n    };\n  }\n\n  /** Writes the pending write to disk */\n  private _writePending(): void {\n    if (this._pendingWrite) {\n      const data = this._pendingWrite.data;\n      // Clear the pending write immediately so that subsequent writes can be queued\n      this._pendingWrite = undefined;\n      super.set(data).catch(() => {\n        // ignore\n      });\n    }\n  }\n}\n"],"names":[],"mappings":"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"}
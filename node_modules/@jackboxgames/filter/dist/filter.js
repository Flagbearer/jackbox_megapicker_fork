var v = Object.defineProperty;
var g = (t, e, r) => e in t ? v(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var h = (t, e, r) => (g(t, typeof e != "symbol" ? e + "" : e, r), r);
function p(t, e) {
  return t.split(".").reduce((r, i) => r === void 0 ? r : r[i], e);
}
class f {
  constructor(e, r) {
    h(this, "definition");
    h(this, "properties");
    this.definition = e;
    const i = Array.isArray(e.propertyKey) ? e.propertyKey : [e.propertyKey];
    this.properties = i.map((n) => p(n, r));
  }
}
class m extends f {
  validate() {
    return this.definition.value === null || typeof this.definition.value != "number" || this.properties.length !== 2 ? !1 : typeof this.properties[0] == "number" && typeof this.properties[1] == "number";
  }
  resolve() {
    const e = Math.min(...this.properties), r = Math.max(...this.properties), i = this.definition.value >= e && this.definition.value <= r;
    return {
      score: i ? 1 : 0,
      isMatch: i,
      isPerfectMatch: i
    };
  }
}
class M extends f {
  validate() {
    return this.definition.value === null || this.properties.length !== 1 ? !1 : typeof this.properties[0] == "boolean";
  }
  resolve() {
    const e = this.properties[0] === this.definition.value;
    return {
      score: e ? 1 : 0,
      isMatch: e,
      isPerfectMatch: e
    };
  }
}
class A extends f {
  validateArray(e) {
    return e == null || !Array.isArray(e) ? !1 : e.every((r) => typeof r == "number" || typeof r == "string");
  }
  validate() {
    return !this.validateArray(this.definition.value) || !this.definition.value.length ? !1 : this.validateArray(this.properties[0]);
  }
  resolve() {
    const e = new Set(this.properties[0]), r = new Set(this.definition.value), i = e.intersection(r), n = i.size / r.size;
    return {
      score: n,
      isMatch: n > 0,
      isPerfectMatch: n === 1,
      matches: Array.from(i)
    };
  }
}
class w extends f {
  validate() {
    return this.definition.value === null || this.definition.minLength !== void 0 && this.definition.value.length < this.definition.minLength || !this.properties.length ? !1 : this.properties.every((e) => typeof e == "string");
  }
  resolve() {
    for (let e = 0; e < this.properties.length; e++)
      if (this.properties[e].toLowerCase().includes(this.definition.value.toLowerCase()))
        return {
          score: 1,
          isMatch: !0,
          isPerfectMatch: !0
        };
    return {
      score: 0,
      isMatch: !1,
      isPerfectMatch: !1
    };
  }
}
class b extends f {
  validate() {
    return this.definition.value === null || !Array.isArray(this.definition.value) || this.definition.value.length !== 2 || typeof this.definition.value[0] != "number" || typeof this.definition.value[1] != "number" || this.properties.length !== 1 ? !1 : typeof this.properties[0] == "number";
  }
  resolve() {
    const e = Math.min(...this.definition.value), r = Math.max(...this.definition.value), i = this.properties[0] >= e && this.properties[0] <= r;
    return {
      score: i ? 1 : 0,
      isMatch: i,
      isPerfectMatch: i
    };
  }
}
class x extends f {
  validate() {
    return this.definition.value === null || this.properties.length !== 1 ? !1 : Array.isArray(this.properties[0]) ? this.properties[0].every((e) => typeof e == "string" || typeof e != "number") : typeof this.properties[0] == "string" || typeof this.properties[0] == "number";
  }
  resolve() {
    const e = Array.isArray(this.properties[0]) ? this.properties[0].includes(this.definition.value) : this.properties[0] === this.definition.value;
    return {
      score: e ? 1 : 0,
      isMatch: e,
      isPerfectMatch: e
    };
  }
}
function P(t) {
  return t ? (Array.isArray(t) ? t : [t]).map((r) => {
    const i = r[0];
    return (i === "+" || i === "-") && (r = r.substring(1)), {
      property: r,
      direction: i === "-" ? "ascending" : "descending"
    };
  }) : [];
}
function y(t, e, r) {
  return r === "ascending" ? e - t : t - e;
}
function S(t, e, r) {
  return r === "ascending" ? t ? -1 : 1 : t ? 1 : -1;
}
function F(t, e, r) {
  return r === "ascending" ? t < e ? 1 : -1 : t < e ? -1 : 1;
}
function k(t, e) {
  const r = P(e);
  return t.sort((i, n) => {
    if (i.score !== n.score)
      return n.score - i.score;
    for (let s = 0; s < r.length; s++) {
      const o = p(r[s].property, i.item), a = p(r[s].property, n.item);
      if (o !== a && typeof o == typeof a) {
        if (typeof o == "number")
          return y(o, a, r[s].direction);
        if (typeof o == "boolean")
          return S(o, a, r[s].direction);
        if (typeof o == "string")
          return F(o, a, r[s].direction);
        if (o instanceof Date)
          return y(o.valueOf(), a.valueOf(), r[s].direction);
      }
    }
    return 0;
  });
}
function B(t, e) {
  switch (e.kind) {
    case "between":
      return new m(e, t);
    case "boolean":
      return new M(e, t);
    case "multi":
      return new A(e, t);
    case "query":
      return new w(e, t);
    case "range":
      return new b(e, t);
    case "value":
      return new x(e, t);
  }
}
function K(t, e) {
  const r = e.map((u) => B(t, u)), i = {};
  let n = 0, s = 0, o = 0, a = !1;
  return r.forEach((u) => {
    if (a || !u.validate())
      return;
    const c = u.resolve();
    if (u.definition.isStrict && !c.isPerfectMatch) {
      a = !0;
      return;
    }
    const d = u.definition.weight ?? 1;
    if (n += d, o += c.score, s += c.score * d, c.matches) {
      let l = u.definition.key;
      l || (l = Array.isArray(u.definition.propertyKey) ? u.definition.propertyKey[0] : u.definition.propertyKey), i[l] = c.matches;
    }
  }), a ? {
    item: t,
    unweightedScore: 0,
    score: 0,
    isMatch: !1,
    isPerfectMatch: !1,
    matches: {},
    isStrictZero: a
  } : n ? {
    item: t,
    unweightedScore: o,
    score: s / n,
    isMatch: s > 0,
    isPerfectMatch: s === n,
    matches: i,
    isStrictZero: a
  } : {
    item: t,
    unweightedScore: 1,
    score: 1,
    isMatch: !0,
    isPerfectMatch: !0,
    matches: {},
    isStrictZero: !1
  };
}
function C(t, e, r) {
  if (!t.length)
    return [];
  const i = t.map((n) => K(n, e));
  return k(i, r);
}
export {
  C as filter
};
